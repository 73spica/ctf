# coding:utf-8

# This file was *autogenerated* from the file solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_0x100000000000000000000000000000087 = Integer(0x100000000000000000000000000000087); _sage_const_128 = Integer(128); _sage_const_0x2e18716441db24baf79ff92393735345 = Integer(0x2e18716441db24baf79ff92393735345); _sage_const_0xc6a5777f4dc639d7d1a50d6521e79bfd = Integer(0xc6a5777f4dc639d7d1a50d6521e79bfd); _sage_const_16 = Integer(16); _sage_const_76716889654539547639031458229653027958 = Integer(76716889654539547639031458229653027958)
from sage.all import *
from Crypto.Util.number import bytes_to_long as b2l
from Crypto.Util.number import long_to_bytes as l2b

# ===== Sagemathの有限体関連の関数 ====
X = GF(_sage_const_2 ).polynomial_ring().gen()

def ntopoly(npoly):
  return sum(c*X**e for e, c in enumerate(Integer(npoly).bits()))

def polyton(poly):
  return sum(int(poly[i])*(_sage_const_1  << i) for i in xrange(poly.degree() + _sage_const_1 ))

def p(n):
  return polyton((ntopoly(n)**_sage_const_2 )%P)

# =====================================

# ===== oneTimePad2.pyからのコピペ =====
def str2num(s):
  return int(s.encode('hex'), _sage_const_16 )

def process1(m, k):
    res = _sage_const_0 
    for i in bin(k)[_sage_const_2 :]:
        res = res << _sage_const_1 ;
        if (int(i)):
            res = res ^ m
        if (res >> _sage_const_128 ):
            res = res ^ P
    return res

def nextrand(rand):
    global N, A, B
    tmp1 = [_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 ]
    tmp2 = [A, B, _sage_const_0 , _sage_const_1 ]
    s = N # 乱数．randが分かれば逆算可能．どんどんN^2された値になっていく．
    N = process1(N, N) # rand0の2乗．どんどん2乗されてく．
    while s: # sが0でない間
        if s % _sage_const_2 : # 偶数なら
            tmp1 = process2(tmp2, tmp1)
        tmp2 = process2(tmp2, tmp2)
        s = s / _sage_const_2 
    return process1(rand, tmp1[_sage_const_0 ]) ** tmp1[_sage_const_1 ] # randは分からないが

# =======================================


# ===== Global Variables =====
P = _sage_const_0x100000000000000000000000000000087 
A = _sage_const_0xc6a5777f4dc639d7d1a50d6521e79bfd 
B = _sage_const_0x2e18716441db24baf79ff92393735345 

# unknown just now.
N = _sage_const_0 

# ===== main =====
def main():
    ciphertxt = open("ciphertxt","r").read()
    ciphertxt = ciphertxt.strip()
    print "ciphertxt  :", ciphertxt
    ciphertxt = ciphertxt.decode("hex")

    known_plain = "One-Time Pad is used here. You won't know that the flag is flag{"
    print "known_plain:", known_plain

    # key.txtのキーの序盤はknown_plainとciphertxtを16byteごとにxorすることで求められる
    # 最後の1ブロックのみフラグが入るため分からない
    keys = []
    i = _sage_const_0 
    block_len = _sage_const_16 
    while True:
        if block_len*(i*_sage_const_1 )>len(known_plain) or block_len*i>=len(known_plain):
            break
        keys.append(b2l(known_plain[block_len*i:block_len*(i+_sage_const_1 )])^b2l(ciphertxt[block_len*i:block_len*(i+_sage_const_1 )]))
        i+=_sage_const_1 
    print "keys:"
    print keys
 
    # ===== A^s を求める =====
    # 式変形することで，ASが以下のようになることが分かる
    # A^s = (Key1 + B/(A+1))/(Key0 + B/(A+1))
    # これらはGF(2^128)の元で計算され，生成多項式はP
    print "===== ガロア体の演算 ===== "
    P_poly = ntopoly(P)
    A_poly = ntopoly(A)
    B_poly = ntopoly(B)
    key0_poly = ntopoly(keys[_sage_const_0 ])
    key1_poly = ntopoly(keys[_sage_const_1 ])

    #deno/nume
    #B/(A+1)
    a1_inv = inverse_mod(A_poly+_sage_const_1 ,P_poly)
    k = process1(B,polyton(a1_inv))
    k_poly = ntopoly(k)

    print "B/(A+1)",k

    deno = key1_poly + k_poly
    nume = key0_poly + k_poly
    print "key1 + B/(A+1)   :", polyton(deno)
    print "key0 + B/(A+1)   :", polyton(nume)

    AS = process1(polyton(deno),polyton(inverse_mod(nume,P_poly)))
    print "(key1 + B/(A+1)) / (key0 + B/(A+1))  :", AS
    
    # calc from "AS" by using pari/gp 
    # $ gp -q log.gp
    s = _sage_const_76716889654539547639031458229653027958 
    N = s
    key = keys[_sage_const_0 ]
    for i in xrange(_sage_const_5 ):
        print l2b(key^b2l(ciphertxt[_sage_const_16 *i:_sage_const_16 *(i+_sage_const_1 )]))
        key = nextrand(key)
        print key
 

if __name__ == '__main__':
    main()

