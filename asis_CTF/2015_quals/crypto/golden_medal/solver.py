# coding:utf-8
import json

def main():
    # Nが小さいので，時間をかければ素因数分解可能
    N = 1746706403628138819652874617603544146781763497759635411369593250306792101284958553453421021829757
    p = 1285380609783825451015579898011805465763518244839
    q = 1358902095093762824984385249873903079031552839163

    x = 464999933592198685609224904351668405644033981511147598208149299121389338123096569361797809760221L # do not use

    # 暗号化される時は，平文のbit列が1が0によってx^miの値が変わる
    # 平文bit列miが1なら，yi^2*xとなる．miが0なら，yi^2となる．つまり各ciはある乱数yi^2にxが掛けられるか否かの違いが出る
    # で，xが掛けられている時(mi=1)はciは平方非剰余になって，xが掛けられていない時(mi=0)はciは平方剰余となる．
    # だから復号の時は，ciが平方費剰余ならmiは1，ciが平方剰余ならmiが0という風に判断すればいい
    # 今回は，暗号化の際のx^m1の部分がx^(b_y.mi) mod Nとなっている部分が異なる．
    # これは変形すると，x^(2b_y+mi)とあり，x^(2b_y)は平方剰余，つまり1となるので，結局はx^miの時とやることは変わらない．

    # 判定方法は2通り．一つはブラム数を利用する方法で，もう一つは通常の復号と同じように平方剰余or平方非剰余を判定する
    # ここで，ブラム数は，xの平方根の一つを，x**( ((p-1)(q-1)+4)/8 ) mod N と求められる
    
    # enc読み込み
    cs = (open("enc.txt","r").read()).strip("enc =  ")
    cs = eval(cs)
    
    tmp =  ((p-1)*(q-1)+4)/8
    ans = ""
    for ci in cs:
        # 通常の判定
        #if pow(ci,(q-1)/2,q)==1:
        #    ans += "0"
        #else:
        #    ans += "1"

        # ブラム数を利用した判定
        if (pow(ci,tmp,N)**2)%N == ci:
            ans += "0"
        else:
            ans += "1"
    print hex(int(ans,2))[2:-1].decode("hex") # ASIS{3c4cbc2d6bc6ebbbbbe967b8af5ac414}

if __name__ == "__main__":
    main()
